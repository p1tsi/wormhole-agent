export default "#define MH_MAGIC 0xfeedface\n#define MH_CIGAM 0xcefaedfe\n#define MH_MAGIC_64 0xfeedfacf\n#define MH_CIGAM_64 0xcffaedfe\n\n#define LC_ENCRYPTION_INFO 0x21\n#define LC_ENCRYPTION_INFO_64 0x2C\n#ifndef NULL\n#define NULL 0\n#endif\n\n#define LC_SEGMENT 0x1\n#define LC_SEGMENT_64 0x19\n\n#define MH_PIE 0x200000\n#define MH_NO_HEAP_EXECUTION 0x1000000\n\ntypedef unsigned int uint32_t;\ntypedef unsigned long long uint64_t;\ntypedef int integer_t;\ntypedef unsigned long uintptr_t;\n\ntypedef long long __int64_t;\ntypedef __int64_t __darwin_off_t;\ntypedef __darwin_off_t off_t;\n\ntypedef integer_t cpu_type_t;\ntypedef integer_t cpu_subtype_t;\ntypedef int vm_prot_t;\n\nstruct mach_header {\n  uint32_t magic;\n  cpu_type_t cputype;\n  cpu_subtype_t cpusubtype;\n  uint32_t filetype;\n  uint32_t ncmds;\n  uint32_t sizeofcmds;\n  uint32_t flags;\n};\n\nstruct mach_header_64 {\n  uint32_t magic;\n  cpu_type_t cputype;\n  cpu_subtype_t cpusubtype;\n  uint32_t filetype;\n  uint32_t ncmds;\n  uint32_t sizeofcmds;\n  uint32_t flags;\n  uint32_t reserved;\n};\n\nstruct load_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n};\n\nstruct encryption_info_command {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t cryptoff;\n  uint32_t cryptsize;\n  uint32_t cryptid;\n};\n\nstruct encryption_info_command_64 {\n  uint32_t cmd;\n  uint32_t cmdsize;\n  uint32_t cryptoff;\n  uint32_t cryptsize;\n  uint32_t cryptid;\n  uint32_t pad;\n};\n\nstruct segment_command {\n  unsigned long cmd;      /* LC_SEGMENT */\n  unsigned long cmdsize;  /* includes sizeof section structs */\n  char segname[16];       /* segment name */\n  unsigned long vmaddr;   /* memory address of this segment */\n  unsigned long vmsize;   /* memory size of this segment */\n  unsigned long fileoff;  /* file offset of this segment */\n  unsigned long filesize; /* amount to map from the file */\n  vm_prot_t maxprot;      /* maximum VM protection */\n  vm_prot_t initprot;     /* initial VM protection */\n  unsigned long nsects;   /* number of sections in segment */\n  unsigned long flags;    /* flags */\n};\n\nstruct segment_command_64 { /* for 64-bit architectures */\n  uint32_t cmd;             /* LC_SEGMENT_64 */\n  uint32_t cmdsize;         /* includes sizeof section_64 structs */\n  char segname[16];         /* segment name */\n  uint64_t vmaddr;          /* memory address of this segment */\n  uint64_t vmsize;          /* memory size of this segment */\n  uint64_t fileoff;         /* file offset of this segment */\n  uint64_t filesize;        /* amount to map from the file */\n  vm_prot_t maxprot;        /* maximum VM protection */\n  vm_prot_t initprot;       /* initial VM protection */\n  uint32_t nsects;          /* number of sections in segment */\n  uint32_t flags;           /* flags */\n};\n\nstruct section {           /* for 32-bit architectures */\n  char sectname[16];       /* name of this section */\n  char segname[16];        /* segment this section goes in */\n  unsigned long addr;      /* memory address of this section */\n  unsigned long size;      /* size in bytes of this section */\n  unsigned long offset;    /* file offset of this section */\n  unsigned long align;     /* section alignment (power of 2) */\n  unsigned long reloff;    /* file offset of relocation entries */\n  unsigned long nreloc;    /* number of relocation entries */\n  unsigned long flags;     /* flags (section type and attributes)*/\n  unsigned long reserved1; /* reserved */\n  unsigned long reserved2; /* reserved */\n};\n\nstruct section_64 {   /* for 64-bit architectures */\n  char sectname[16];  /* name of this section */\n  char segname[16];   /* segment this section goes in */\n  uint64_t addr;      /* memory address of this section */\n  uint64_t size;      /* size in bytes of this section */\n  uint32_t offset;    /* file offset of this section */\n  uint32_t align;     /* section alignment (power of 2) */\n  uint32_t reloff;    /* file offset of relocation entries */\n  uint32_t nreloc;    /* number of relocation entries */\n  uint32_t flags;     /* flags (section type and attributes)*/\n  uint32_t reserved1; /* reserved (for offset or index) */\n  uint32_t reserved2; /* reserved (for count or sizeof) */\n  uint32_t reserved3; /* reserved */\n};\n\n#ifdef __LP64__\ntypedef struct mach_header_64 mach_header_t;\ntypedef struct segment_command_64 segment_command_t;\ntypedef struct section_64 section_t;\ntypedef struct nlist_64 nlist_t;\n#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64\n#else\ntypedef struct mach_header mach_header_t;\ntypedef struct segment_command segment_command_t;\ntypedef struct section section_t;\ntypedef struct nlist nlist_t;\n#define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT\n#endif\n\n#ifndef SEG_DATA_CONST\n#define SEG_DATA_CONST \"__DATA_CONST\"\n#endif\n#ifndef SEG_TEXT\n#define SEG_TEXT \"__TEXT\"\n#endif\n\n#define SEG_LINKEDIT \"__LINKEDIT\"\n\ntypedef unsigned int uint;\n\n#define FOR_EACH_SEGMENT(MH, ...)                                              \\\n  {                                                                            \\\n    segment_command_t *seg;                                                    \\\n    uintptr_t cur = (uintptr_t)MH + sizeof(mach_header_t);                     \\\n    for (uint i = 0; i < MH->ncmds; i++, cur += seg->cmdsize) {                \\\n      seg = (segment_command_t *)cur;                                          \\\n      __VA_ARGS__                                                              \\\n    }                                                                          \\\n  }\n\nstruct result {\n  void *ptr;\n  uint32_t offset;\n  uint32_t size;\n\n  uint32_t offset_id;\n  uint32_t size_id;\n};\n\nstruct result find_encryption_info(struct mach_header *);\nint pie(struct mach_header *);\n\nint strcmp(const char *, const char *);\nint issection(section_t *, const char *);\n\nstruct result find_encryption_info(struct mach_header *mh) {\n  struct load_command *lc;\n  struct encryption_info_command *eic;\n  int i = 0;\n  struct result ret = {0};\n\n  if (mh->magic == MH_MAGIC_64 || mh->magic == MH_CIGAM_64) {\n    lc = (struct load_command *)((unsigned char *)mh +\n                                 sizeof(struct mach_header_64));\n  } else {\n    lc = (struct load_command *)((unsigned char *)mh +\n                                 sizeof(struct mach_header));\n  }\n\n  for (i = 0; i < mh->ncmds; i++) {\n    if (lc->cmd == LC_ENCRYPTION_INFO || lc->cmd == LC_ENCRYPTION_INFO_64) {\n      eic = (struct encryption_info_command *)lc;\n      if (!eic->cryptid)\n        break;\n\n      ret.ptr = eic;\n      ret.offset = eic->cryptoff;\n      ret.size = eic->cryptsize;\n      ret.offset_id = (uint32_t)((void *)&eic->cryptid - (void *)mh);\n      ret.size_id = sizeof(eic->cryptid);\n      return ret;\n    }\n\n    lc = (struct load_command *)((unsigned char *)lc + lc->cmdsize);\n  }\n\n  return ret;\n}\n\nint pie(struct mach_header *mh) { return mh->flags & MH_PIE; }\n\nvoid sections(struct mach_header *mh,\n              void (*yield)(const char *, uintptr_t, uintptr_t)) {\n#ifdef __LP64__\n#define INVALID_MAGIC(mh) mh->magic != MH_MAGIC_64 && mh->magic != MH_CIGAM_64\n#else\n#define INVALID_MAGIC(mh) mh->magic != MH_MAGIC && mh->magic != MH_CIGAM\n#endif\n\n  if (INVALID_MAGIC(mh))\n    return;\n  uintptr_t slide = 0;\n  FOR_EACH_SEGMENT(mh, {\n    if (seg->cmd == LC_SEGMENT_ARCH_DEPENDENT &&\n        strcmp(seg->segname, SEG_TEXT) == 0) {\n      slide = (uintptr_t)mh - seg->vmaddr;\n    }\n  })\n\n  FOR_EACH_SEGMENT(mh, {\n    if (seg->cmd == LC_SEGMENT_ARCH_DEPENDENT) {\n      for (uint j = 0; j < seg->nsects; j++) {\n        section_t *sect = (section_t *)(cur + sizeof(segment_command_t)) + j;\n        uintptr_t p = sect->addr + slide;\n        yield(sect->sectname, p, p + sect->size);\n      }\n    }\n  })\n\n  return;\n}\n\nint issection(section_t *sec, const char *name) {\n  int i = 0;\n  const char *s1 = sec->sectname;\n  const char *s2 = name;\n  while (*s1 && (*s1 == *s2)) {\n    s1++;\n    s2++;\n    if (++i >= sizeof(sec->sectname) - 1)\n      break;\n  }\n  return *(const unsigned char *)s1 - *(const unsigned char *)s2 == 0;\n}\n\nint strcmp(const char *s1, const char *s2) {\n  while (*s1 && (*s1 == *s2)) {\n    s1++;\n    s2++;\n  }\n  return *(const unsigned char *)s1 - *(const unsigned char *)s2;\n}\n"